---
import { SITE } from '../config';
import '../styles/global.scss';

export interface Props {
  author?: string;
  title?: string;
  description?: string;
  ogImg?: string;
}

const {
  author = SITE.author,
  title = SITE.title,
  description = SITE.description,
  ogImg = SITE.ogImg,
} = Astro.props;

const ogImgURL = new URL(ogImg, Astro.url.origin);
---

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<meta name="format-detection" content="telephone=no,address=no" />
<title>{title}</title>
<meta name="description" content={description} />
<meta name="author" content={author} />
<!-- favicon -->
<link rel="icon" type="image/png" href="/favicon.png" sizes="32x32" />
<link rel="apple-touch-icon" type="image/png" href="/apple-touch-icon.png" sizes="180x180" />
<link rel="manifest" href="/manifest.json" />
<!-- OGP -->
<meta property="og:title" content={title} />
<meta property="og:description" content={description} />
<meta property="og:site_name" content={title} />
<meta property="og:url" content={Astro.url} />
<meta property="og:image" content={ogImgURL} />
<meta property="og:locale" content="ja_JP" />
<meta property="og:type" content="website" />
<meta property="twitter:card" content="summary_large_image" />
<meta property="twitter:url" content={Astro.url} />
<meta property="twitter:title" content={title} />
<meta property="twitter:description" content={description} />
<meta property="twitter:image" content={ogImgURL} />

<body class="ly_bg_gradation">
  <slot />

  <style lang="scss">
    @use '../styles/variables/other' as *;

    .ly_bg_gradation {
      position: relative;
      animation: GradationBg 10s ease infinite;
      background: linear-gradient(
        45deg,
        #827dad,
        #8e8dba,
        #999ec7,
        #a5afd5,
        #b1c0e2,
        #becce9,
        #ccd1ea,
        #d9d6eb,
        #e6dbeb,
        #f3e0ec
      );
      background-size: 800% 800%;

      &::after {
        content: '';
        position: fixed;
        z-index: -1;
        top: -10rem;
        left: -10rem;
        width: calc(100% + 20rem);
        height: calc(100% + 20rem);
        animation: noise 1s steps(2) infinite;
        background: url(#{$img-path}noise.png);
      }
    }

    @keyframes GradationBg {
      0% {
        background-position: 0% 50%;
      }

      50% {
        background-position: 100% 50%;
      }

      100% {
        background-position: 0% 50%;
      }
    }

    @keyframes noise {
      0% {
        transform: translate3d(0, 9rem, 0);
      }

      20% {
        transform: translate3d(-8rem, 2rem, 0);
      }

      40% {
        transform: translate3d(-2rem, 7rem, 0);
      }

      60% {
        transform: translate3d(2rem, 6rem, 0);
      }

      80% {
        transform: translate3d(-9rem, 1rem, 0);
      }

      to {
        transform: translate3d(-7rem, 0, 0);
      }
    }
  </style>

  <script>
    /**
     * 画像遅延読み込み
     */
    window.addEventListener('load', () => {
      if ('loading' in HTMLImageElement.prototype) {
        const images = document.querySelectorAll(
          'img[loading="lazy"]'
        ) as NodeListOf<HTMLImageElement>;
        images.forEach(img => {
          if (img.dataset.src != null) {
            img.src = img.dataset.src;
          }
        });
        const imageSrcset = document.querySelectorAll(
          'img[data-srcset]'
        ) as NodeListOf<HTMLImageElement>;
        imageSrcset.forEach(img => {
          if (img.dataset.srcset != null) {
            img.srcset = img.dataset.srcset;
          }
        });
        const sources = document.querySelectorAll(
          'source[data-srcset]'
        ) as NodeListOf<HTMLSourceElement>;
        sources.forEach(source => {
          if (source.dataset.srcset != null) {
            source.srcset = source.dataset.srcset;
          }
        });
      } else {
        const script = document.createElement('script');
        script.src = 'https://cdnjs.cloudflare.com/ajax/libs/lazysizes/5.3.2/lazysizes.min.js';
        document.body.appendChild(script);
      }
    });

    /**
     * アニメーション
     */
    import 'typed-query-selector';

    const animationTargets = document.querySelectorAll('.js_anime');

    const options = {
      root: null,
      rootMargin: '20px 0px -70px',
      threshold: 0,
    };
    const observer = new IntersectionObserver(scrollInAnime, options);
    animationTargets.forEach(animationTarget => {
      observer.observe(animationTarget);
    });

    // rootと交差時にふわっと表示させる
    function scrollInAnime(entries: IntersectionObserverEntry[]) {
      entries.forEach((entry: IntersectionObserverEntry, index) => {
        const delay = index * 300;
        if (entry.isIntersecting) {
          setTimeout(() => {
            entry.target.classList.add('is_active');
          }, delay);
          observer.unobserve(entry.target);
        }
      });
    }
  </script>
</body>
